//// 
//// Autogenerated by xlw 
//// Do not edit this file, it will be overwritten 
//// by InterfaceGenerator 
////

#include "xlw/MyContainers.h"
#include <xlw/CellMatrix.h>
#include "mxlwcppinterface.h"
#include <xlw/xlw.h>
#include <xlw/XlFunctionRegistration.h>
#include <stdexcept>
#include <xlw/XlOpenClose.h>
#include <xlw/HiResTimer.h>
using namespace xlw;

namespace {
const char* LibraryName = "MyInterestRateModelLibrary";
};


// registrations start here


namespace
{
XLRegistration::Arg
mxlw_NormalOptionValueArgs[]=
{
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The volatility of the underlying ","B"},
{ "isCall"," Whether it is a call or put ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_NormalOptionValue("xlmxlw_NormalOptionValue",
"NormalOptionValue",
" Normal model option value ",
LibraryName,
mxlw_NormalOptionValueArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_NormalOptionValue(
double T,
double F_0,
double K,
double sigma,
LPXLFOPER isCalla)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);





XlfOper isCallb(
	(isCalla));
bool isCall(
	isCallb.AsBool("isCall"));

double result(
	mxlw_NormalOptionValue(
		T,
		F_0,
		K,
		sigma,
		isCall)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_NormalOptionValueDerivArgs[]=
{
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The volatility of the underlying ","B"},
{ "isCall"," Whether it is a call or put ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_NormalOptionValueDeriv("xlmxlw_NormalOptionValueDeriv",
"NormalOptionValueDeriv",
" Calculate the vega of the normal model ",
LibraryName,
mxlw_NormalOptionValueDerivArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_NormalOptionValueDeriv(
double T,
double F_0,
double K,
double sigma,
LPXLFOPER isCalla)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);





XlfOper isCallb(
	(isCalla));
bool isCall(
	isCallb.AsBool("isCall"));

double result(
	mxlw_NormalOptionValueDeriv(
		T,
		F_0,
		K,
		sigma,
		isCall)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_LognormalOptionValueArgs[]=
{
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The volatility of the underlying ","B"},
{ "isCall"," Whether it is a call or put ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_LognormalOptionValue("xlmxlw_LognormalOptionValue",
"LognormalOptionValue",
"Lognormal model option value ",
LibraryName,
mxlw_LognormalOptionValueArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_LognormalOptionValue(
double T,
double F_0,
double K,
double sigma,
LPXLFOPER isCalla)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);





XlfOper isCallb(
	(isCalla));
bool isCall(
	isCallb.AsBool("isCall"));

double result(
	mxlw_LognormalOptionValue(
		T,
		F_0,
		K,
		sigma,
		isCall)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_ConvertLognormalToNormalVolArgs[]=
{
{ "lognormalOptionPrice"," The option price from the Black model ","B"},
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "isCall"," Whether it is a call or put ","XLF_OPER"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_ConvertLognormalToNormalVol("xlmxlw_ConvertLognormalToNormalVol",
"ConvertLognormalToNormalVol",
"Convert Lognormmal vol to Normal vol using the Newton's method ",
LibraryName,
mxlw_ConvertLognormalToNormalVolArgs,
5
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_ConvertLognormalToNormalVol(
double lognormalOptionPrice,
double T,
double F_0,
double K,
LPXLFOPER isCalla)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);





XlfOper isCallb(
	(isCalla));
bool isCall(
	isCallb.AsBool("isCall"));

double result(
	mxlw_ConvertLognormalToNormalVol(
		lognormalOptionPrice,
		T,
		F_0,
		K,
		isCall)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_SABRImpliedNormalVolArgs[]=
{
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The vol_0 ","B"},
{ "alpha"," alpha in the SABR model ","B"},
{ "beta"," beta in the SABR model ","B"},
{ "rho"," rho in the SABR model ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_SABRImpliedNormalVol("xlmxlw_SABRImpliedNormalVol",
"SABRImpliedNormalVol",
"Get the SABR implied normal volatility ",
LibraryName,
mxlw_SABRImpliedNormalVolArgs,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_SABRImpliedNormalVol(
double T,
double F_0,
double K,
double sigma,
double alpha,
double beta,
double rho)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);








double result(
	mxlw_SABRImpliedNormalVol(
		T,
		F_0,
		K,
		sigma,
		alpha,
		beta,
		rho)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_SABRImpliedLogNormalVolArgs[]=
{
{ "T"," The maturity of the option ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The vol_0 ","B"},
{ "alpha"," alpha in the SABR model ","B"},
{ "beta"," beta in the SABR model ","B"},
{ "rho"," rho in the SABR model ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_SABRImpliedLogNormalVol("xlmxlw_SABRImpliedLogNormalVol",
"SABRImpliedLogNormalVol",
"Get the SABR implied log normal volatility ",
LibraryName,
mxlw_SABRImpliedLogNormalVolArgs,
7
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_SABRImpliedLogNormalVol(
double T,
double F_0,
double K,
double sigma,
double alpha,
double beta,
double rho)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);








double result(
	mxlw_SABRImpliedLogNormalVol(
		T,
		F_0,
		K,
		sigma,
		alpha,
		beta,
		rho)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

namespace
{
XLRegistration::Arg
mxlw_MonteCarloGetSABROptionPriceArgs[]=
{
{ "T","too lazy to comment this one ","B"},
{ "F_0"," The current forward swap rate ","B"},
{ "K"," The strike ","B"},
{ "sigma"," The vol_0 ","B"},
{ "alpha"," alpha in the SABR model ","B"},
{ "beta"," beta in the SABR model ","B"},
{ "rho"," rho in the SABR model ","B"},
{ "isCall","Whether it is a call or put ","XLF_OPER"},
{ "numOfPath"," Number of Monte Carlo simulation paths ","B"},
{ "stepsInYear"," Number of time step in one path ","B"}
};
  XLRegistration::XLFunctionRegistrationHelper
registermxlw_MonteCarloGetSABROptionPrice("xlmxlw_MonteCarloGetSABROptionPrice",
"MonteCarloGetSABROptionPrice",
"Monte Carlo Simulation for SABR model ",
LibraryName,
mxlw_MonteCarloGetSABROptionPriceArgs,
10
,false
,false
,""
,""
,false
,false
,false
);
}



extern "C"
{
LPXLFOPER EXCEL_EXPORT
xlmxlw_MonteCarloGetSABROptionPrice(
double T,
double F_0,
double K,
double sigma,
double alpha,
double beta,
double rho,
LPXLFOPER isCalla,
double numOfPatha,
double stepsInYeara)
{
EXCEL_BEGIN;

	if (XlfExcel::Instance().IsCalledByFuncWiz())
		return XlfOper(true);








XlfOper isCallb(
	(isCalla));
bool isCall(
	isCallb.AsBool("isCall"));

int numOfPath(
	static_cast<int>(numOfPatha));

int stepsInYear(
	static_cast<int>(stepsInYeara));

double result(
	mxlw_MonteCarloGetSABROptionPrice(
		T,
		F_0,
		K,
		sigma,
		alpha,
		beta,
		rho,
		isCall,
		numOfPath,
		stepsInYear)
	);
return XlfOper(result);
EXCEL_END
}
}



//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoOpen
//////////////////////////

//////////////////////////
// Methods that will get registered to execute in AutoClose
//////////////////////////

